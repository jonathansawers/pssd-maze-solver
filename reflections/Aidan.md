# Aidan Chan - Reflection

Working on the Maze Solver project was a really rewarding experience. I was responsible for creating all the maze generation algorithms from scratch, including DFS and Prim’s, and I also took charge of refactoring the code to make the program flow smoothly for users. This meant improving the MenuSystem, Maze, MazeDisplay, and MazeSolver classes, as well as adding display enhancements that made the interface clearer and easier to navigate.

One of the biggest challenges was designing the generation algorithms to be both efficient and easy to integrate. This was my independent challenge so I spent a lot of time thinking about how each maze could be built dynamically while still working seamlessly with the rest of the system. Writing these algorithms gave me a deeper understanding of how they behave in realistic scenarios and how their performance changes with different maze sizes. I realised that the dfs generation was a lot more relevant to maze generation in this scenario as the Prim's algorithm was more suited to game map development due to the open areas. However, for the sake of extending different maze designs, I decided to keep both generation algorithms so that users can experiment with different algorithms.

Refactoring was another major focus I was responsible for. I wanted to make sure the code was organised, readable, and reliable, while keeping memory management clean and predictable. This also meant improving the user interface: adding appropriate user prompts, multiple display modes, and structured information screens so users always know what’s happening. I thought about the user experience, making the program feel intuitive and polished rather than just functional. Some of the prompts in the terminal were incorrect or did not flow correctly, e.g. when viewing the maze display after solving using an algorithm, it would sometimes not display the solution. So, I had to change the logic of the menusystem and mazedisplay slightly so that it reflected the prompts well. Therefore, maze display would show just the mazes and the maze solving would show the maze with solutions as well.

Through this work, I learned a lot about balancing algorithmic logic with usability. Not only was I trying to make the program work, but also to make it easy and enjoyable to interact with (from the perspective of users). I also strengthened my understanding in object-oriented design, understanding how clear separation of responsibilities can make a program easier to maintain and extend. By keeping code organised in their respective classes and their header and cpp files, it made it easier to understand the code flow and make any corrections. Furthermore, the makefile was easy to implement but was extremely useful for this project as it meant that compilation could be done faster i.e. typing make instead of g++ files.cpp etc. every single time we had to test the program.

Overall, this project taught me not just technical skills, but also how to think from a user’s perspective. I’m proud of how the maze generation, refactoring, and display improvements came together to create a cohesive, interactive experience. Looking forward, I’d love to add more algorithms, expand display animations, and introduce automated tests, but I’m happy with the way the program works and how much I’ve learned from building it.