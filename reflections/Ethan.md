# Ethan Lawrie - Reflection



Throughout this project, I have been able to work in a variety of different aspects of the features of the maze, ranging from the algorithms for solving it to the display. I worked specifically on all of the three algorithms that solve the maze, and worked with Aidan who was designing the base Maze classes and generation. The three algorithms that I worked on were the DFS, BFS and A* algorithms. I also worked on the display aspect of the maze, mostly on display of the solution paths. I structured outputs and solutions to integrate efficiently and simply with the functions made by Jonothan in his maze display classes he designed. I worked on some extra information for displaying the pathing for solutions as well, like calculating the directional travel for each point to show the general direction paths would take in a maze, which would be difficult normally to distinguish if all the paths were shown such as in DFS or BFS (as the branches would be ambiguous to which one was the true path). I also implemented animations for the project, and also timing of the algorithms to tell how fast they ran.  



There were multiple challenges that occurred throughout the development and different stages of the project. The first larger problem that I encountered was when deciding how the maze cells should be structured, as I was wanting to have different types of mazes potentially (eg hexagonal or irregularly shaped ones). This lead to the choice of representing the cell connections in a contiguous 2d array, or similar to how linked lists do it by pointing to other cells. Me and Aidan decided that it was out of the original project scope we intented to do as well as constricting for time constraints so we decided to go with the simpler and more efficient option of just 2d rectangular mazes. Another big challenge I had was building the different algorithms to store pathing details/data based on whether it was collecting the full path or the optimum straight path. The full path was usually easy as it could be collected through the in order traversal, but the other optimum path was not, as it would not necessarily know if the last flow of steps it took was the right one. I was able to eventually solve this for most of the algorithm functions by storing parent info for each point, and then retracing back through the parent vector at the end to get the path. For the DFS algorithm it was simpler, as all I needed to do was to pop the paths that are branches and keep the main solution path, which I made work by returning a boolean back through the DFS recursion, and if it was completed (true) it would push, otherwise pop. Then in the case of tracking the full pathing, I just pushed additionally nodes that it visits when backtracking.        

There were some points where I delayed doing it until later because I thought it would be more complex and time consuming, such as implementing the animations. The animations actually did not take that long, as I realised I could just keep a trace array for up to that animation point which would animate in the order of the array items, and it would call the display function and then wait a certain amount of time then clear the command line and repeat. I think that there are also more areas that I could have improved or included in the project, such as having different types of maze shapes (which would make some algorithms more efficient), or different maze solver algorithms for both solving it blind and with the endpoint in mind. I would also implement a system for battling out different algorithms to solve the maze, since it already has the functionality I built to time how long algorithms run for. I think there are also areas that could have been slightly more optimised, such as with the grid constructors and reference passing, for which I tried to make efficient and not using extra space but at some points I had to compromise. 


Throughout this project I have learnt many different things about how different find algorithms work, and also about efficient coding and working and collaborating in a team setting. I learnt about the A* algorithm, and about how heuristics work and why they aren't always optimum solutions which was interesting coming from just learning about definitive algorithms in PSSD. Coding the algorithms and also having the knowledge that mazes could potential be 100 x 100 in size (10^6 magnitude), this pushed me to try and make the solutions efficient so they would be runnable in acceptable time. The collaboration in this project has been useful in improving my communication skills, as me and my group members would meet up and discuss, as well as ensure we were properly using version control to segment our features and push when we were ready. 

Overall, this project was a useful and also interesting project to work on with the two other members of my group. I have had group projects where the communication has been off, so development was hindered due to people not knowing entirely what they needed to do. This project was different, and me and the group members were able to design the different classes to work and interface properly, and there were minimal conflicts when merging code. I am proud of this project, as every part of it is polished now that it is finished, and it works well and is interesting to run different algorithms on different maze types to see the results and performances. 




