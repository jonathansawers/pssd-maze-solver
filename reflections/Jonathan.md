# Jonathan Sawers - Reflection

This project strengthened both my C++ fundamentals and my ability to design a cohesive and intuitive user experience for a console-based application. My primary contribution was the architecture and implementation of the interactive menu system that connects maze generation, solving, and display into a unified experience. I aimed to make the program intuitive and reliable while maintaining clean integration between its core components and ensuring safe memory management throughout.

A major part of my work involved developing the MenuSystem, which orchestrates the entire user flow across main, generation, solver, and display submenus. I placed particular emphasis on user guidance through clear prompts, colour-coded feedback, and safeguards that prevent invalid operations. Input validation uses reusable helper functions that handle integer and yes/no prompts, eliminating crashes and improving the overall user experience. I also implemented explicit lifecycle management for the Maze, MazeDisplay, and MazeSolver objects to prevent memory leaks and ensure predictable behaviour. Configuration screens were introduced to allow users to set start and end positions and choose display modes for the solver, such as basic, coloured, or symbolic visualisations. This was complemented by seamless integration with multiple maze generation and solving algorithms, including depth-first search (DFS), Prim’s algorithm, breadth-first search (BFS), and A*, as well as a consistent results view showing path length and computation time. Additionally, I contributed to refining the Maze class to allow the menu layer to interact reliably with maze dimensions, positions, and grid operations.

Throughout this process, I developed a deeper appreciation for object-orientated software design. Dividing the program into clear, distinct responsibilities for generation, solving, display, and user interface made the system easier to understand, maintain, and extend. I adopted a defensive programming mindset by enforcing thorough input validation and flow control to prevent invalid states, such as attempting to solve or display a maze before one is generated. In terms of memory management, I gained practical experience in ensuring safe ownership and proper clean-up of dynamically allocated objects, reducing the risk of leaks in a long-running console environment. From a user experience perspective, I focused on readability and consistency by incorporating structured prompts, intuitive navigation, and visual clarity through colour and layout. This attention to presentation, combined with features like pause and clear functionality, helped keep the interface organised and accessible.

Integrating algorithms such as DFS, Prim’s, BFS, and A* into an interactive environment also deepened my understanding of their behaviour and performance characteristics. Measuring path length and timing in real execution contexts provided valuable insight into their trade-offs, and exposing features like “show full navigation” allowed users to explore how each algorithm progresses through the maze.

Collaboration and workflow discipline were also central to my approach. I structured code and naming conventions to prioritise readability and maintainability, enabling my co-contributors to integrate additional algorithms or display modes with minimal friction. I adopted a workflow of small, testable changes and conducted manual walkthroughs to verify correctness across edge cases, such as dimension bounds, coordinate ranges, and return flows.

Looking ahead, I see opportunities to extend the project by completing full BFS and A* implementations, abstracting display configuration and timing, and introducing automated tests for input validation and state transitions. Overall, I am pleased with how the menu system contributed to making the project feel polished, functional, and user-friendly.