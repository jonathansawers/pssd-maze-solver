# Jonathan Sawers - Reflection

This project strengthened both my C++ fundamentals and my ability to design a cohesive and intuitive user experience for a console-based application. I took the lead in developing the core architecture and implementation of the interactive menu system that connects maze generation, solving, and display into a unified experience. My work primarily focused on making the program intuitive and reliable while maintaining clean integration between its core components and ensuring safe memory management throughout.

I worked independently on developing and designing the MenuSystem, which is responsible for the entire user flow across main, generation, solver, and display submenus. I placed particular emphasis on user guidance through clear prompts, colour-coded feedback, and safeguards that prevent invalid operations. Input validation uses reusable helper functions that handle integer and yes/no prompts, eliminating crashes and improving the overall user experience.

I also implemented explicit lifecycle management for the Maze, MazeDisplay, and MazeSolver objects to prevent memory leaks and ensure predictable behaviour. Configuration screens were introduced to allow users to set start and end positions and choose display modes for the solver, such as basic, coloured, or symbolic visualisations. This was complemented by integration with multiple maze generation and solving algorithms, including depth-first search (DFS), Prim’s algorithm, breadth-first search (BFS), and A* (implemented by my colleagues) as well as a consistent results view showing path length and computation time. Additionally, I contributed to refining the Maze class to allow the menu layer to interact reliably with maze dimensions, positions, and grid operations.

Throughout this process, I developed a deeper appreciation for object-orientated software design. Dividing the program into clear, distinct responsibilities for generation, solving, display, and user interface made the system easier to understand, maintain, and extend. I adopted a defensive programming mindset by using input validation and flow control to prevent invalid states, such as attempting to solve or display a maze before one is generated. In terms of memory management, I gained practical experience in ensuring safe ownership and proper clean-up of dynamically allocated objects, reducing the risk of leaks in a long-running console environment.

Integrating algorithms such as DFS, Prim’s, BFS, and A* into an interactive environment also deepened my understanding of their behaviour and performance characteristics. Measuring path length and timing in real execution contexts provided valuable insight into their trade-offs, and exposing features like “show full navigation” allowed users to explore how each algorithm progresses through the maze. I had never heard of Prim's algorithm or BFS before, so I learned about how these algorithms work for pathfinding.

Collaboration and workflow discipline were also central to my approach. I structured code and naming conventions to prioritise readability and maintainability, enabling my co-contributors to integrate additional algorithms or display modes with minimal friction. I adopted a workflow of small, testable changes and conducted manual walkthroughs to verify correctness across edge cases, such as dimension bounds, coordinate ranges, and return flows.

To improve the project, I would develop automated tests for input validation and state transitions. I created a GitHub action for checking that the program compiled using `g++`, but it just exits the application automatically and doesn't test anything beyond compilation.

Overall, I am pleased with how the menu system contributed to making the project feel polished, functional, and user-friendly.
